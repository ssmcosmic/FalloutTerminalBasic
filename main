import pygame
import random


#----------------------------------------------------------------------------------------------------------------------
                                          #Setup
#----------------------------------------------------------------------------------------------------------------------
pygame.init()
screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
clock = pygame.time.Clock()
running = True
width,height = screen.get_size()
folder_directory = "D:\Coding Projects\Fallout - Revisioned\wordbank.txt" # Change to wherever the wordbank is stored


# Colors
faded_green = (0,100,0)
bg_green =  (0,5,0)
words_color = (31,255,64)

# Surfaces
crt_lines_surface = pygame.Surface((width,height), pygame.SRCALPHA)
glow_surface = pygame.Surface((width,height))
glow_surface.fill((0,40,0))

# Fonts
text_font = pygame.font.Font("FSEX300.ttf", int(height*0.04))
char_width, char_height = text_font.size("A")

# Game stats
attempts_remaining = 4
target = "" # The correct word
take_input = True # Only take input if word not found


# Text Generation Variables
symbols = "[]{}()!@#$%^&*_+-=/?"
left_col_words = []
right_col_words = []
L_addresses = []
R_addresses = []
logs = [] # log of clicks made, later improvement: track indices not elements, since eg. ) can be in multiple indices

L_word_rows_indices = {} # dictionary of (row,word) for the left column where there is a word, used to remove duds
R_word_rows_indices = {}


# Left Column: Starting X and Y coords for the first char 
L_col_x_start = width*0.2
L_col_y_start = height* (1/25 + 0.195)

R_col_x_start = width*0.56
R_col_y_start = height* (1/25 + 0.195)


line_spacing = height/25

left_hitbox = pygame.Rect(L_col_x_start, L_col_y_start, char_width * 12, line_spacing * 16)
right_hitbox = pygame.Rect(R_col_x_start, R_col_y_start, char_width * 12, line_spacing * 16)


# Other

open_brackets = ['[', '(', '{' ]
closed_brackets = [']', ')','}']
L_pair_found_indices = []
R_pair_found_indices = []

#----------------------------------------------------------------------------------------------------------------------
                                          #Display Methods
#----------------------------------------------------------------------------------------------------------------------

def _add_crt_effect(screen):
    for y in range(0,height,4):
        pygame.draw.line(crt_lines_surface, (0, 20, 0, 80), (0, y), (width, y))
    
    screen.blit(crt_lines_surface, (0, 0))


def _terminal_effects(screen):    
    # Apply the CRT lines
    screen.blit(crt_lines_surface,(0,0))
    # Add a glow effect
    screen.blit(glow_surface, (0,0), special_flags=pygame.BLEND_RGB_ADD)

def renderText(text,font,color,relative_x,relative_y,center = True):

    text_surface = font.render(text,True,color)
    
    pos_x = width * relative_x
    pos_y = height * relative_y

    text_rect = text_surface.get_rect()

    if center:
        text_rect.center = (pos_x, pos_y)
    else:
        text_rect.topleft = (pos_x, pos_y)
        
    screen.blit(text_surface, text_rect)





#----------------------------------------------------------------------------------------------------------------------
                                          #Backend Methods
#----------------------------------------------------------------------------------------------------------------------

def _random_grid_symbols():
    """
    Generates 16 strings of length 12, of random symbols
    To be used to inject words for each column, at random

    """
    global left_col_words, right_col_words

    left_col_words = [''.join(random.choices(symbols,k=12)) for i in range(16)]
    right_col_words = [''.join(random.choices(symbols,k=12)) for i in range(16)]



def _word_injection():

    """
    Injects words into a randomly generated block of symbols above and also chooses a random word as target
    """
    global left_col_words, right_col_words,target
    already_injected = []
    L_rows_added_to = [] # Avoid injecting word to a row already having a word (left col)
    R_rows_added_to = [] # Avoid injecting word to a row already having a word (right col)
    
    with open(folder_directory) as file:
        words = [words.strip() for words in file]
        
    # Generate a random word for a random line. Ensure atleast 6 words generated

    while len(already_injected) < 10:
        for line in range(16):

            L_generate_word = bool(random.randint(0,1))
            R_generate_word = bool(random.randint(0,1))


            # Word generation for left side
            if L_generate_word and line not in L_rows_added_to:

                L_rows_added_to.append(line)
                L_random_start_index = random.randint(0,11)
            
                L_max_word_size = 11-L_random_start_index
            
                # Filter words that cannot be injected, then randomly choose from them
                L_word_filter = [w for w in words if (len(w) <= L_max_word_size) and (w not in already_injected)]
            
                # Inject into left side
                if L_word_filter:
                    injected_word = random.choice(L_word_filter)
                    already_injected.append(injected_word)               

                
                    substring_to_replace = left_col_words[line][L_random_start_index:L_random_start_index + len(injected_word)]
                    new_string = left_col_words[line].replace(substring_to_replace,injected_word)
                    left_col_words[line] = new_string

                    L_word_rows_indices[line] = injected_word

            

                if R_generate_word and line not in R_rows_added_to:

                    R_rows_added_to.append(line)
            
                    R_random_start_index = random.randint(0,11)
                    R_max_word_size = 11-R_random_start_index

                    # Filter words that cannot be injected, then randomly choose from them
                    R_word_filter = [w for w in words if (len(w) <= R_max_word_size) and (w not in already_injected)]

                    # Inject into right side
                    
                    if R_word_filter:
                        injected_word = random.choice(R_word_filter)
                        already_injected.append(injected_word)               

                    
                        substring_to_replace = right_col_words[line][R_random_start_index:R_random_start_index + len(injected_word)]
                        new_string = right_col_words[line].replace(substring_to_replace,injected_word)
                        right_col_words[line] = new_string

                        R_word_rows_indices[line] = injected_word

      
        target = random.choice(already_injected)
       
                

def _hexadecimal_address():
        start_address = random.randint(0x1000,0xF000)
        global L_addresses, R_addresses

        for i in range(32):

            address_generated = start_address + random.randint(12,48)
            string_val =  f"0x{address_generated:04X}"

            if i < 16:
                L_addresses.append(string_val)
            else:
                R_addresses.append(string_val)


            

def _pixel_pos_to_indices(mouse_x,mouse_y, x_start,y_start):

    #left column
    
    """
    Stats to consider

    height = 1920
    width = 1080

    first char of first col: 
    L_col_x_start = width*0.2
    L_col_y_start = height* (1/25 + 0.195)
    

    last char of first col (the diagnonal corners): 
    x = width*0.1
    y = height* (17/25 + 0.195)

    width of a char 
    Create a rectangle based on that for mouse detection
    Get coords and translate based on all this information


    Rectangle coordinates:
    top left
    top right
    bottom left
    bottom right:

    translate (x,y) -> (row,col) using start stats

    mouse_x = L_col_x_start + (j*char_width)
    j = int((mouse_x - L_col_x_start) / char_width)
    
    mouse_y = L_col_y_start + height*(i/25 + 0.195)
    mouse_y - L_col_y_start = height*(i/25 + 0.195)

    i = int(25*((mouse_y - L_col_y_start)/(height)) - 0.195)






    My version:
    mouse_x = L_col_x_start + height(j/25 + 0.195)
    j = int((mouse_x - L_col_x_start) / char_width)

    
    
    i = int(25*((mouse_y - L_col_y_start)/(height)) - 0.195)
    j = int((mouse_x - L_col_x_start) / char_width)

    """

    global height, width
   

    i = int(25*((mouse_y - y_start)/(height)) - 0.195)
    j = int((mouse_x - x_start) / char_width)
    return (i,j)





def _find_word(character,row,col,word_list):
    """
    If a alphachar is found, look both ways to find the whole word by building it piece by piece

    character -> Any char the mouse hovers over
    X -> The row pos of the char
    Y -> The col pos of the char
    """

    formed_word = ""
   
    if character.isalpha():
        
        # Find start of string and go forward, keeping the boundaries in check

        if(col == 0):
            pass
        else:
            while word_list[row][col-1].isalpha() and col >= 0:
                col -= 1
        
        # Now build forward
        while word_list[row][col+1].isalpha() and col < 12:
                formed_word += word_list[row][col]
                col += 1
        
        formed_word += word_list[row][col]

   
        return formed_word
    else:
        return character
        
        

def _remove_dud():
    """
    If a pair of brackets is found, this method is triggered
    Remove one incorrect word from either column, replaced with symbols

    column_choice:
        0 -> left column
        1 -> right column

    L_word_rows_indices -> [(row,word)]

    
    Find a 

    Make sure the same pair cannot be selected again

    """
    global L_word_rows_indices, R_word_rows_indices
    global left_col_words, right_col_words
    
    rows_tried = []
    sequence = ""

    column_choice = random.randint(0,1) 

    # Left side
    if(column_choice == 0):

        random_row = random.randint(0,15)
        rows_tried.append(random_row)
        
        while random_row not in L_word_rows_indices.keys() and random_row in rows_tried or L_word_rows_indices[random_row] == target:
            random_row = random.randint(0,15)
            
            if random_row in L_word_rows_indices.keys():
                break
            
            rows_tried.append(random_row)
    

        # Replace word with ....

        for c in range(12):
            if left_col_words[random_row][c].isalpha():
                sequence += "."
            else:
                sequence += left_col_words[random_row][c]
        
        left_col_words[random_row] = sequence


        
        
    
     # Right side

    rows_tried = []
    if(column_choice == 1):

        random_row = random.randint(0,15)
        rows_tried.append(random_row)
        
        while random_row not in R_word_rows_indices.keys() and random_row in rows_tried or R_word_rows_indices[random_row] == target:
            random_row = random.randint(0,15)
            
            if random_row in R_word_rows_indices.keys():
                break
            
            rows_tried.append(random_row)
    

         # Replace word with ....

        for c in range(12):
            if right_col_words[random_row][c].isalpha():
                sequence += "."
            else:
                sequence += right_col_words[random_row][c]

        right_col_words[random_row] = sequence



        


        


def _reset_tries():
    global attempts_remaining
    attempts_remaining = 4


            
def _search_pairs(row,col,word_list):
    """
    Search pairs of brackets if hovered char is not an alphachar
    Search carried from 
    Once a pair is found, generate a number between 0,1
    0 -> remove dud
    1 -> reset tries

    Returns a pair of (action,sequence) where action = 0 (remove dud), 1 (reset tries), -1 (no pair found), and sequence = the sequence between the bracket pair
    """

    global open_brackets, closed_brackets
    char = word_list[row][col]
    bracket_index = -1
    sequence =  word_list[row][col]

    if char.isalpha() == False: 
        # Check if open bracket. Store the corresponding index of the closed bracket
        for index,bracket in enumerate(open_brackets):
            if char == bracket:
                bracket_index = index
        
        if bracket_index == -1:
               return (-1,"NO PAIRS")
           
        # Now look through the line until the first closed bracket is found
        for s in range(col + 1,12):
            sequence += word_list[row][s]
            

            if word_list[row][s] == closed_brackets[bracket_index]:

                choice = random.randint(0,1)

                if(choice == 0):
                    return(0,sequence)
                elif(choice == 1):
                    return (1,sequence)

            
    return (-1,"NO PAIRS") 








#----------------------------------------------------------------------------------------------------------------------
                                          #Main
#----------------------------------------------------------------------------------------------------------------------

# Draw the lines before running else they get drawn 60 times a second (performance)
_add_crt_effect(screen)

# Generate words
_random_grid_symbols()
_word_injection()

# Generate addresses
_hexadecimal_address()


while running:
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # Apply screen effects and then add text
    screen.fill(bg_green)
    _terminal_effects(screen)

    

    # Introductory text
    renderText("ROBCO INDUSTRIES (TM) TERMLINK PROTOCOL", text_font, words_color, 0.01, 0.05, center=False)
    renderText("ENTER PASSWORD NOW", text_font, words_color, 0.01, 0.085, center=False)
    renderText("{} ATTEMPT(S) LEFT: ".format(attempts_remaining) + "[]"*attempts_remaining, text_font, words_color, 0.01, 0.145, center=False)

    # Left Column and Addresses
    

    for i in range(16):
        renderText(left_col_words[i], text_font, words_color, 0.2, (i+1)/25 + 0.195, center=False)
        renderText(L_addresses[i], text_font, words_color, 0.1, (i+1)/25 + 0.195, center=False)

    
    # Right Column and Addresses
    for i in range(16):
        renderText(right_col_words[i], text_font, words_color, 0.56, (i+1)/25 + 0.195, center=False)
        renderText(R_addresses[i], text_font, words_color, 0.46, (i+1)/25 + 0.195, center=False)





    # Mouse checking only when hovering around the two columns (use colliders)
    mouse_pos = pygame.mouse.get_pos()

    if(attempts_remaining == 0):
        if "Out of tries!" not in logs:
            logs.append("Out of tries!")
    else:

        if(left_hitbox.collidepoint(mouse_pos)):
            
            mouse_x = mouse_pos[0]
            mouse_y = mouse_pos[1]

            X,Y = _pixel_pos_to_indices(mouse_x,mouse_y, L_col_x_start,L_col_y_start)


            # Display text as it is hovered over
            
            display_text = left_col_words[X][Y]
            display_text = _find_word(display_text,X,Y,left_col_words)
            pair_found = _search_pairs(X,Y,left_col_words)
            
            # If a pair of brackets is found, display the sequence of symbols
        
            if pair_found[0] != -1:
                display_text = pair_found[1]
                
                

            renderText('>'+display_text, text_font, words_color, 0.76, (16)/25 + 0.195, center=False)
            

            # Add to logs and then we display all logs outside of the two checks
            if event.type == pygame.MOUSEBUTTONDOWN and take_input:
                
                            
                if (pair_found[0] != -1) and (X,Y) not in L_pair_found_indices:
                    L_pair_found_indices.append((X,Y))
                    if pair_found[0] == 0:
                        _remove_dud()
                        logs.append("Dud removed")
                        logs.append(pair_found[1])
                    elif pair_found[0] == 1:
                        _reset_tries()
                        logs.append("Tries reset")
                        logs.append(pair_found[1])


            
                if display_text in logs:
                    pass
                else:
                    if display_text[0].isalpha() == True:
                        logs.append(display_text)
                        attempts_remaining -= 1

                
                # Will change how to deal with storing only once later
                if display_text == target:

                    take_input = False

                    if "Exact match!" not in logs:
                        logs.append("Exact match!")
                    
                    if "Please wait" not in logs:
                        logs.append("Please wait")
                    
                    if "while system!" not in logs:
                        logs.append("while system!")

                    if "is accessed" not in logs:
                        logs.append("is accessed")

        

        if(right_hitbox.collidepoint(mouse_pos)):
            
            mouse_x = mouse_pos[0]
            mouse_y = mouse_pos[1]

            X,Y = _pixel_pos_to_indices(mouse_x,mouse_y, R_col_x_start,R_col_y_start)


            # Display text as it is hovered over
            
            display_text = right_col_words[X][Y]        
            display_text = _find_word(display_text,X,Y,right_col_words)
            pair_found = _search_pairs(X,Y,right_col_words)

            # If a pair of brackets is found, display the sequence of symbols
            if pair_found[0] != -1:
                display_text = pair_found[1]
                

            renderText('>'+display_text, text_font, words_color, 0.76, (16)/25 + 0.195, center=False)

            # Add to logs and then we display all logs outside of the two checks
            if event.type == pygame.MOUSEBUTTONDOWN and take_input:

            
                    
                
                if (pair_found[0] != -1) and (X,Y) not in R_pair_found_indices:
                    R_pair_found_indices.append((X,Y))
                    if pair_found[0] == 0:
                        _remove_dud()
                        logs.append("Dud removed")
                    elif pair_found[0] == 1:
                        _reset_tries()
                        logs.append("Tries reset")

                

                if display_text in logs:
                    pass
                else:
                    if display_text[0].isalpha() == True:
                        logs.append(display_text)
                        attempts_remaining -= 1
                        
            
                # Will change how to deal with storing only once later
                if display_text == target:
                    
                    take_input = False

                    if "Exact match!" not in logs:
                        logs.append("Exact match!")
                    
                    if "Please wait" not in logs:
                        logs.append("Please wait")
                    
                    if "while system!" not in logs:
                        logs.append("while system!")

                    if "is accessed" not in logs:
                        logs.append("is accessed")

            

                
            

                

    

    # Need to keep log size constant, eliminate the oldest entry when almost full
    for index,entry in enumerate(logs[::-1]):
         renderText('>'+entry, text_font, words_color, 0.76, (15-index)/25 + 0.185, center=False)

    if len(logs) > 15:
        del logs[0]
    
  



    pygame.display.flip()
    clock.tick(60)




pygame.quit()





